package com.github.sanforjr2021.ability.enderian;

import com.github.sanforjr2021.FragaliciousOrigins;
import com.github.sanforjr2021.ability.Ability;
import com.github.sanforjr2021.origins.Enderian;
import com.github.sanforjr2021.util.ConfigHandler;
import com.github.sanforjr2021.util.MessageUtil;
import org.bukkit.EntityEffect;
import org.bukkit.Location;
import org.bukkit.World;
import org.bukkit.block.Block;
import org.bukkit.entity.Player;
import org.bukkit.scheduler.BukkitRunnable;
import org.bukkit.util.BlockIterator;
import org.bukkit.util.Vector;

public class TeleportAbility extends Ability {
    private static int TELEPORT_COOLDOWN;
    private static int TELEPORT_DISTANCE;
    public TeleportAbility(Enderian enderian) {
        if(enderian.getCooldown() != 0){
            sendCooldownMessage("Teleport", enderian.getCooldown(), enderian.getPlayer());
        }else {
            Player player = enderian.getPlayer();
            Vector direction = player.getLocation().getDirection();
            Location safeLocation = getClosestSolidBlock(player);
            //if cannot find solid block, generate a safe place to teleport.
            if (safeLocation == null) {
                Vector targetLocation = player.getLocation().toVector().add(direction.multiply(TELEPORT_DISTANCE));
                safeLocation = findSafeLocation(targetLocation.toLocation(player.getWorld()));
            } else {
                safeLocation = findSafeLocation(safeLocation);
            }
            if (safeLocation != null) {
                safeLocation.setYaw(player.getLocation().getYaw());
                safeLocation.setPitch(player.getLocation().getPitch());
                player.playEffect(EntityEffect.TELEPORT_ENDER);
                player.teleport(safeLocation);
                enderian.setCooldown(TELEPORT_COOLDOWN);
                player.playEffect(EntityEffect.TELEPORT_ENDER);
                new BukkitRunnable() {
                    @Override
                    public void run() {
                        if(enderian.getCooldown() == 0){
                            cancel();
                        }
                        enderian.setCooldown(enderian.getCooldown()-1);
                    }
                }.runTaskTimer(FragaliciousOrigins.getInstance(),20l, 20l);
            } else {
                MessageUtil.sendMessage("No valid teleport spot.", player);
            }
        }
    }
    //Location code generated by ChatGPT
    private Location findSafeLocation(Location location) {
        // Check blocks above head and below feet
        World world = location.getWorld();
        int x = location.getBlockX();
        int y = location.getBlockY();
        int z = location.getBlockZ();
        Block headBlock = world.getBlockAt(x, y + 2, z);
        Block feetBlock = world.getBlockAt(x, y - 1, z);
        Block belowBlock = world.getBlockAt(x, y - 2, z);
        if (headBlock.getType().isAir() && feetBlock.getType().isAir() && belowBlock.getType().isSolid()) {
            return new Location(world, x + 0.5, y, z + 0.5, location.getYaw(), location.getPitch());
        }
        // If not safe, search for a safe location nearby
        for (int yOffset = -1; yOffset <= 3; yOffset++) {
            Block candidateBlock = world.getBlockAt(x, y - yOffset, z);
            Block canidateFeetBLock = world.getBlockAt(x, y - yOffset + 1, z);
            Block canidateHeadBlock = world.getBlockAt(x, y - yOffset + 2, z);
            if (candidateBlock.getType().isSolid() && canidateHeadBlock.getType().isAir() && canidateFeetBLock.getType().isAir()) {
                return new Location(world, x + 0.5, y - yOffset + 1, z + 0.5, location.getYaw(), location.getPitch());
            }
        }
        return null; // No safe location found
    }

    public static Location getClosestSolidBlock(Player player){
        Location eyeLocation = player.getEyeLocation();
        BlockIterator blockIterator = new BlockIterator(eyeLocation, 0.0, TELEPORT_DISTANCE);
        while (blockIterator.hasNext()) {
            Block block = blockIterator.next();
            if (!block.getType().isAir() && block.getType().isSolid()) {
                return block.getLocation();
            }
        }
        return null;
    }
    public static void reload(){
        TELEPORT_COOLDOWN = ConfigHandler.getEnderianTeleportCooldown();
        TELEPORT_DISTANCE = ConfigHandler.getEnderianTeleportDistance();
    }
}